- To generate certificates, there are different tools available

- easyrsa
- openssl
- cfssl
- And many others…

### Using OPENSSL to generate Certificates

1. Generate a private key using the following command

		openssl genrsa -out <server|client|root (ca)>.key 2048

1. Generate a CSR using the created private key with the "openssl request" command as follows

- In the CSR, specify (at minimum):

- The name of the component that the certificate is for
- The "Common Name" or CN field

		openssl req -new -key CERTIFICATE_KEY_NAME -subj "/CN=CHOOSE_COMMON_NAME" -out SERVER|CLIENT|ROOT.csr

- Be sure to provide a relevant Common Name (CN) as this is the name that the kubectl client authenticates with when running kubectl commands

- So this is the name you will see in the audit logs and other locations

- A CSR is like a certificate with all of your details but with no signature

1. Sign the certificate using the openssl x509 command

1. Specify the name of the CSR previously generated

		openssl x509 -req -in CSR_NAME -CA CA_CERTIFICATE_NAME -Cakey CA_KEY_FILE-out SERVER|CLIENT|ROOT_CA.crt

If self-sign

		openssl x509 -req -in CSR_NAME -signkey CERTIFICATE_NAME -out SERVER_CLIENT_ROOT_CA.crt

- Generate the CA certificate first (if creating imperatively) as you will use it to sign all other certificates

### Generating client certificates

- When signing the client certificates, be sure use the CA certificate and key

		openssl x509 -req -in CLIENT_CSR_NAME -CA CA_CERTIFICATE_NAME -CAkey CA_KEY -out CLIENT_NAME.crt

- For the client certificates, generate signed certificates for

- The admin user

- The signed certificate is what the admin user will use to authenticate to the Kubernetes cluster
- Be sure to add the group details for the admin user in the certificate to confirm that this is the admin user and not just another user

- The kube-scheduler

- As this is a system component, it's name must be prefixed with the word "system"

- The kube-controller-manager

- As this is a system component, it's name must be prefixed with the word "system"

- Kube-proxy

- Creating certificates is similar to creating new user accounts as the certificate would be equivalent to the username and the private key would be equivalent to the password

- This is just a more secure process

- Add group details to the CSR by using the "O" parameter

![[certc-1.png]]

- In the REST API call to the kube-apiserver, you can use the certificate to authenticate instead of the username and password

- Specify the client private key and certificate and the CA certificate as options

![[certc-2.png]]

- You can move all authentication parameters into the kubeconfig file and specify the kube-apiserver endpoint details that the certificates use

- This is what most Kubernetes clients do

![[certc-3.png]]

- In Kubernetes, for various components to verify each other, they all need a copy of the CAs root certificate

- So whenever you configure a server or client with certificates, you will need to specify the CA root certificate as well

### Generating server certificates

- For the server certificates, generate signed certificates for

- The etcd server

- The etcd server can be deployed as a cluster across multiple servers
- The etcd server also requires a root (ca) certificate to verify the clients

- The kube-apiserserver

- There are many "additional names" for the kube-apiserver which all must be present in the certificate as they are used by the other cluster components

- kubernetes
- kubernetes.default
- kubernetes.default.svc
- kubernetes.default.svc.cluster.local
- It's ip address

- All of the additional

- The kubelet server

- The kubelet server is an HTTPS API server that runs on each node

- For the etcd server, to secure communication between different members in the cluster, we must generate additional peer certificates

- Once the certificates are generated, specify them while starting the etcd server
- There are key and cert file options where you specify the etcd server keys
- There are other options available for specifying the peer certificates

![[certc-4.png]]

- When creating the kube-apiserver certificate, in order to specify all of the "alternative names", you must create an openssl config file (ends in .cnf)

- Specify the alternative names in the "alt names" section
- Pass this file as an option when generating the CSR

![[certc-5.png]]

- Remember that when communicating with the etcd and kubelet servers from the kube-apiserver, that the kube-apiserver is a client in these cases and as such, must be passed to the kube-apiserver service file along with the etcd and kubelet certificate info

![[certc-6.png]]

- As kubelet is responsible for managing and monitoring the nodes as well as any information regarding what pods are being scheduled on what nodes, there needs to be a key-certificate pair on each node in the cluster

-  These key-certificate pairs will be named after their nodes

- Once the kubelet key-certificate pairs are created, use them in the kubelet config file

- As always, also passing in the CA certificate

![[certc-7.png]]

- Remember that when communicating with the kube-apiserver from kubelet, that kubelet is a client in this case and as such, each of the node's certificates must be generated as well

- These will be named after the node
- The naming is the "system" keyword, the "node" keyword, and the node name

![[certc-8.png]]

- The nodes must be added to the group "system:nodes" this way the group can be specified in the certificate and the API server gives each kubelet the correct permissions