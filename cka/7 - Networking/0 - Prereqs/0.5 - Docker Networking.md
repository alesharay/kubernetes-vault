- When you run a container, you have different networking options to choose from
	- None
	- Host
	- Bridge

- With the none network, the Docker container is not attached to any network, the container cannot reach the outside world and no one from the outside world can reach the container

![[docker-network-1.png]]

- If you run multiple containers with the none network, they are all created without being part of any network and cannot talk each other or to the outside world

![[docker-network-2.png]]

- With the host network, the container is attached to the host's network which means there is no network isolation between the host and the container

![[docker-network-3.png]]

- With the host network, if you deploy a web application listening on port 80 in the container, then the web application is available on port 80 on the host without having to do any additional port mapping
	- If you try to run another instance of the same container that listens on the same port, it won't work as they share hosts

![[docker-network-4.png]]

- Networking between two processes cannot listen on the same port at the same time

- With the bridge network, an internal private network is created with the Docker host and containers attached to it

![[docker-network-5.png]]

- With the bridge network, each device connecting to the network get their own internal private network IP address on this network

![[docker-network-6.png]]

### Bridge

- When Docker is installed on the host, it creates an internal private network called bridge by default
	- You can see this when you run the `docker network ls` command

![[docker-network-7.png]]

- Docker calls its bridge network "bridge", but on the host, the name is "docker-0" (or bridge0 for mac)
	- This can be seen in the output of the `ip link` command

![[docker-network-8.png]]

- Docker creates the bridge network by (under the umbrella) running the `ip link add` command with the type set to bridge

- When Docker first creates the bridge network, notice that the interface/network starts off being DOWN

![[docker-network-9.png]]

- REMEMBER: we said that the bridge network is like an interface to the host but a switch to namespaces or containers within the host

- The interface on the host is assigned an IP address (under the umbrella) using the `ip addr add` command which you can see using the `ip addr` command

![[docker-network-10.png]]

- Whenever a container is created, Docker creates a network namespace for it
	- Run the `ip netns` command to list the namespace

![[docker-network-11.png]]

- You can see the namespace associated with each container in the output of the `docker inspect` command

![[docker-network-12.png]]

- Although technically they are not, containers and network namespaces are normally used to mean the same thing and are used interchangeably

- In order for Docker to attach the container to the bridge, it creates a virtual cable (pipe / veth pair) with the two interfaces on the ends

- If you run the `ip link` command on the Docker host, you see one end of the pipe which is attached to the local bridge (docker-0/bridge0). Running the same command with the "-n" option and the name of the namespace, it lists the other end of the pipe within the container namespace

![[docker-network-13.png]]

![[docker-network-14.png]]

- The pipe also gets an IP address assigned within the network, which can be viewed by running the `ip addr` command within the container's namespace

![[docker-network-15.png]]

- The same procedure is followed every time a new container is created:
	- Docker creates a namespace
	- Docker creates a pair of interfaces
	- Docker creates a pipe
	- Docker attaches one end (interface) to the bridge networkÂ  and the other end (interface) to the container

- Interface pairs can be identified using their numbers; odd and even form a pair

![[docker-network-16.png]]


- Once the containers are all part of the bridge network, they can all communicate with each other

### Port Mapping

- Since containers are within private networks inside the host, only other containers in the same network or the host itself can access the container applications

- If you try to access a container app outside of the host, you will not be able to

- To allow external users to access applications hosted on containers, Docker provides a port publishing or port mapping option.

- When running containers, tell Docker to map the port on the host to the port on the container that the application listens to
	- Any traffic on the Docker host will now be forwarded to the container on those ports

![[docker-network-17.png]]

- The way Docker forwards traffic from one port to another is creating IPTables entries into the NAT table to append rules to the pre-routing chain which changes the destination port from the one on the host to that on the containers

![[docker-network-18.png]]

- You can see the IPTables rules Docker creates when you list them in the IPTables

![[docker-network-19.png]]